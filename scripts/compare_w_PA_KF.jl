####
# Compare NRG results to Parquet results (in low-coupling regime)
#   also compare to NRG results that were generated by Jeongmin
####
using TCI4Keldysh
using HDF5
using Plots
using OffsetArrays
using MAT

# NRG convention for fermionic legs:
# 1         1'
# \        /
#  \______/
#   |    |          = <1 1' 3 3'>
#   |____|
#  /      \
# /        \
# 3'        3



# NRG frequency convention:
# t- channel
# 
# ν         ν+ω
# \        /
#  \______/
#   |    |
#   |____|
#  /      \
# /        \
# ν′        ν′+ω


# p- channel
# 
# ν         -ν′-ω       ω_p = ν′_t - ν_t 
# \        /            ν_p = ν_t
#  \______/             ν′_p= ν′_t
#   |    |
#   |____|
#  /      \
# /        \
# ν′       -ν-ω


# a- channel
# 
# ν         ν′          ω_a = ν_t - ν′_t
# \        /            ν_a = ν_t
#  \______/             ν′_a= ν_t + ω_t
#   |    |
#   |____|
#  /      \
# /        \
# ν+ω      ν′+ω



# MBEsolver frequency convention:
# t- channel: same as in NRG
# 
# p- channel: difference to NRG: ω_p --> -ω_p
# 
# ν         ω-ν′        ω_p = ω_t + ν_t + ν′_t
# \        /            ν_p = ν_t
#  \______/             ν′_p= ν′_t
#   |    |
#   |____|
#  /      \
# /        \
# ν′        ω-ν
#
# a-channel: same as in NRG


begin
    # set frequency conventions
    
    ωconvMat_t = [
        0 -1  0;
        1  1  0;
       -1  0 -1;
        0  0  1;
    ]
    #ωconvMat_p = [   # NRG convention
    #    0 -1  0;
    #    -1  0 -1;
    #    1  1  0;
    #    0  0  1;
    #]
    ωconvMat_p = [    # MBEsolver convention
        0 -1  0;
        1  0 -1;
       -1  1  0;
        0  0  1;
    ]
    ωconvMat_a = [
        0 -1  0;
        0  0  1;
        -1  0 -1;
        1  1  0;
    ]

    ### deduce frequency conventions for 2p and 3p vertex contributions:

    # K1t = ["Q12", "Q34"]
    # K1p = ["Q13", "Q24"]
    # K1a = ["Q14", "Q23"])
    ωconvMat_K1t = reshape([
        sum(view(ωconvMat_t, [1,2], 1), dims=1);
        sum(view(ωconvMat_t, [3,4], 1), dims=1);
    ], (2,1))
    ωconvMat_K1p = reshape([
        sum(view(ωconvMat_p, [1,3], 1), dims=1);
        sum(view(ωconvMat_p, [2,4], 1), dims=1);
    ], (2,1))
    ωconvMat_K1a =  reshape([
        sum(view(ωconvMat_a, [1,4], 1), dims=1);
        sum(view(ωconvMat_a, [2,3], 1), dims=1);
    ], (2,1))

    # K2t = ("Q34", "1", "1dag")
    # K2p = ("Q24", "1", "3")
    # K2a = ("Q23", "1", "3dag")

    ωconvMat_K2t = [
        sum(view(ωconvMat_t, [3,4], [1,2]), dims=1);
        view(ωconvMat_t, [1,2], [1,2])
    ]

    ωconvMat_K2p = [
        sum(view(ωconvMat_p, [2,4], [1,2]), dims=1);
        view(ωconvMat_p, [1,3], [1,2])
    ]


    ωconvMat_K2a = [
        sum(view(ωconvMat_a, [2,3], [1,2]), dims=1);
        view(ωconvMat_a, [1,4], [1,2])
    ]


    # K2′t = ("Q12", "3", "3dag")
    # K2′p = ("Q13", "1dag", "3dag")
    # K2′a = ("Q14", "3", "1dag")

    ωconvMat_K2′t = [
        1  0;
        0  1;
        -1 -1;
    ]
    ωconvMat_K2′t = [
        sum(view(ωconvMat_t, [1,2], [1,3]), dims=1);
        view(ωconvMat_t, [3,4], [1,3])
    ]

    ωconvMat_K2′p = [
        sum(view(ωconvMat_p, [1,3], [1,3]), dims=1);
        view(ωconvMat_p, [2,4], [1,3])
    ]


    ωconvMat_K2′a = [
        sum(view(ωconvMat_a, [1,4], [1,3]), dims=1);
        view(ωconvMat_a, [2,3], [1,3])
    ]
end

begin
    # set physical parameters
    u = 0.5; 
    #u = 1.0

    U_PA = 1.
    Δ_PA = U_PA / (π * u)

    U = 0.05;
    Δ = U / (π * u)
    T = 0.01*U

    # broadening parameters:
    sigmak=[0.6]; 
    γ=1. *T;
end

# selfenergy:
output_filename = "data/NRG_MF_vertex_dump.h5"
PA_filename = "/home/Anxiang.Ge/Desktop/PhD/mfrg_Data/MF_finiteT/T=00p01_U=1/parquetInit4_U_over_Delta=1.570796_T=0.010000_eVg=0.000000_n1=4097_n2=513_n3=257_version3_final.h5"
#PA_filename = "/home/Anxiang.Ge/Desktop/PhD/mfrg_Data/MF_finiteT/T=00p01_U=1/parquetInit4_U_over_Delta=2.328759_T=0.010000_eVg=0.000000_n1=4097_n2=513_n3=257_version3_final.h5"
file_PA = h5open(PA_filename, "r")
Σ_PA = read(file_PA, "selflist")[:] / Δ_PA


PSFpath = "data/SIAM_u=0.50/PSF_nz=2_conn_zavg/"
#PSFpath = "data/PSF_nz=2_conn_zavg_u=1.00/"

N_MF = 1024
ω_fer = collect(LinRange(-1,1,N_MF))

function compute_Π_p_DK(G, N_ωpos)
    # Π_t(ω,ν) = G(ν) G(-ω+ν)


    M = div.(length(G), 2)
    G = OffsetArrays.OffsetVector(G, -M-1) # axes = -M:M-1
    Π_t = OffsetArrays.OffsetArray(zeros(ComplexF64, 2*N_ωpos+1, 2*M), (-N_ωpos-1, -M-1)) # axes = (-N_ωpos:N_ωpos, -M:M-1)
    #println("M = ", M)
    #println("axes(G)", axes(G))
    #println("axes(Π_t)", axes(Π_t))

    for i in axes(Π_t, 1)

        Π_t[i,-M + max(i, 0): M-1 + min(i,0)] .= G[-M-min(i, 0):M-1-max(i,0)]
    end
    Π_t .*= G'
    return Π_t
end


function compute_Π_t(G, N_ωpos)
    # Π_t(ω,ν) = G(ν) G(ω+ν)


    M = div.(length(G), 2)
    G = OffsetArrays.OffsetVector(G, -M-1) # axes = -M:M-1
    Π_t = OffsetArrays.OffsetArray(zeros(ComplexF64, 2*N_ωpos+1, 2*M), (-N_ωpos-1, -M-1)) # axes = (-N_ωpos:N_ωpos, -M:M-1)
    #println("M = ", M)
    #println("axes(G)", axes(G))
    #println("axes(Π_t)", axes(Π_t))

    for i in axes(Π_t, 1)

        Π_t[i,-M - min(i, 0): M-1 - max(i,0)] .= G[-M+max(i, 0):M-1+min(i,0)]
    end
    Π_t .*= G'
    return Π_t
end



G0_inv   = ω_fer #.+ im*Δ*sign.(imag.(ω_fer)) .+ U/2
G        = TCI4Keldysh.FullCorrelator_KF(PSFpath, ["F1", "F1dag"]; flavor_idx=1, ωs_ext=(ω_fer,), ωconvMat=reshape([ 1; -1], (2,1)), name="SIAM 2pG", sigmak, γ);
G_aux    = TCI4Keldysh.FullCorrelator_KF(PSFpath, ["Q1", "F1dag"]; flavor_idx=1, ωs_ext=(ω_fer,), ωconvMat=reshape([ 1; -1], (2,1)), name="SIAM 2pG", sigmak, γ);
G_QQ_aux = TCI4Keldysh.FullCorrelator_KF(PSFpath, ["Q1", "Q1dag"]; flavor_idx=1, ωs_ext=(ω_fer,), ωconvMat=reshape([ 1; -1], (2,1)), name="SIAM 2pG", sigmak, γ);

G_data      = TCI4Keldysh.precompute_all_values(G)

plot(-1/π*imag.(G_data[:,2,1]))
plot(real.(G_data[:,2,1]))
@assert maximum(abs.(G_data[:,2,1] - conj.(G_data[:,1,2]))) < 1e-14
@assert maximum(abs.(real.(G_data[:,2,2]))) < 1e-14

G_aux_data  = TCI4Keldysh.precompute_all_values(G_aux)
G_QQ_aux_data=TCI4Keldysh.precompute_all_values(G_QQ_aux)


########################################################################################################
### Yet to be implemented:
### compute selfenergy via (a)symmetric estimators
### construct symmetric estimators for vertex functions
