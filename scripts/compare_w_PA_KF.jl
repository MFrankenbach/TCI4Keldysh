####
# Compare NRG results to Parquet results (in low-coupling regime)
#   also compare to NRG results that were generated by Jeongmin
####
using Revise
using TCI4Keldysh
using HDF5
using Plots
using OffsetArrays
using MAT

# NRG convention for fermionic legs:
# 1         1'
# \        /
#  \______/
#   |    |          = <1 1' 3 3'>
#   |____|
#  /      \
# /        \
# 3'        3



# NRG frequency convention:
# t- channel
# 
# ν         ν+ω
# \        /
#  \______/
#   |    |
#   |____|
#  /      \
# /        \
# ν′        ν′+ω


# p- channel
# 
# ν         -ν′-ω       ω_p = ν′_t - ν_t 
# \        /            ν_p = ν_t
#  \______/             ν′_p= ν′_t
#   |    |
#   |____|
#  /      \
# /        \
# ν′       -ν-ω


# a- channel
# 
# ν         ν′          ω_a = ν_t - ν′_t
# \        /            ν_a = ν_t
#  \______/             ν′_a= ν_t + ω_t
#   |    |
#   |____|
#  /      \
# /        \
# ν+ω      ν′+ω



# MBEsolver frequency convention:
# t- channel: same as in NRG
# 
# p- channel: difference to NRG: ω_p --> -ω_p
# 
# ν         ω-ν′        ω_p = ω_t + ν_t + ν′_t
# \        /            ν_p = ν_t
#  \______/             ν′_p= ν′_t
#   |    |
#   |____|
#  /      \
# /        \
# ν′        ω-ν
#
# a-channel: same as in NRG


begin
    # set frequency conventions
    
    ωconvMat_t = [
        0 -1  0;
        1  1  0;
       -1  0 -1;
        0  0  1;
    ]
    #ωconvMat_p = [   # NRG convention
    #    0 -1  0;
    #    -1  0 -1;
    #    1  1  0;
    #    0  0  1;
    #]
    ωconvMat_p = [    # MBEsolver convention
        0 -1  0;
        1  0 -1;
       -1  1  0;
        0  0  1;
    ]
    ωconvMat_a = [
        0 -1  0;
        0  0  1;
        -1  0 -1;
        1  1  0;
    ]

    ### deduce frequency conventions for 2p and 3p vertex contributions:

    # K1t = ["Q12", "Q34"]
    # K1p = ["Q13", "Q24"]
    # K1a = ["Q14", "Q23"])
    ωconvMat_K1t = reshape([
        sum(view(ωconvMat_t, [1,2], 1), dims=1);
        sum(view(ωconvMat_t, [3,4], 1), dims=1);
    ], (2,1))
    ωconvMat_K1p = reshape([
        sum(view(ωconvMat_p, [1,3], 1), dims=1);
        sum(view(ωconvMat_p, [2,4], 1), dims=1);
    ], (2,1))
    ωconvMat_K1a =  reshape([
        sum(view(ωconvMat_a, [1,4], 1), dims=1);
        sum(view(ωconvMat_a, [2,3], 1), dims=1);
    ], (2,1))

    # K2t = ("Q34", "1", "1dag")
    # K2p = ("Q24", "1", "3")
    # K2a = ("Q23", "1", "3dag")

    ωconvMat_K2t = [
        sum(view(ωconvMat_t, [3,4], [1,2]), dims=1);
        view(ωconvMat_t, [1,2], [1,2])
    ]

    ωconvMat_K2p = [
        sum(view(ωconvMat_p, [2,4], [1,2]), dims=1);
        view(ωconvMat_p, [1,3], [1,2])
    ]


    ωconvMat_K2a = [
        sum(view(ωconvMat_a, [2,3], [1,2]), dims=1);
        view(ωconvMat_a, [1,4], [1,2])
    ]


    # K2′t = ("Q12", "3", "3dag")
    # K2′p = ("Q13", "1dag", "3dag")
    # K2′a = ("Q14", "3", "1dag")

    ωconvMat_K2′t = [
        1  0;
        0  1;
        -1 -1;
    ]
    ωconvMat_K2′t = [
        sum(view(ωconvMat_t, [1,2], [1,3]), dims=1);
        view(ωconvMat_t, [3,4], [1,3])
    ]

    ωconvMat_K2′p = [
        sum(view(ωconvMat_p, [1,3], [1,3]), dims=1);
        view(ωconvMat_p, [2,4], [1,3])
    ]


    ωconvMat_K2′a = [
        sum(view(ωconvMat_a, [1,4], [1,3]), dims=1);
        view(ωconvMat_a, [2,3], [1,3])
    ]
end

begin
    # set physical parameters
    u = 0.5; 
    #u = 1.0

    U_PA = 1.
    Δ_PA = U_PA / (π * u)

    U = 0.05;
    Δ = U / (π * u)
    T = 0.01*U

    # broadening parameters:
    sigmak=[0.4]; 
    γ=1. *T;
end



PSFpath = "data/SIAM_u=0.50/PSF_nz=2_conn_zavg/"     # directory with all PSFs


f = matopen("data/SIAM_u=0.50/V_KF_ph/V_KF_U2_1.mat")
#keys(f)
K1t_NRG = read(f, "CFdat")["Ggrid"][1][1,1,:,:,:,:,:]
ω_K1t_NRG = read(f, "CFdat")["ogrid"][1][:]
#K1_CF = read(f, "CF")
#T

#N_MF = 200+1# * 4*4*2
#ω_fer = collect(LinRange(-1,1,N_MF))
#ω_bos = collect(LinRange(-1,1,N_MF))
ω_fer = ω_K1t_NRG
ω_bos = ω_K1t_NRG
ω_fer[101]

K1t    = TCI4Keldysh.FullCorrelator_KF(PSFpath, ["Q12", "Q34"]; T, flavor_idx=1, ωs_ext=(ω_bos,), ωconvMat=reshape([ 1; -1], (2,1)), name="SIAM 2pG", sigmak, γ, estep=2000);
K1t_data = TCI4Keldysh.precompute_all_values(K1t)


l = @layout([a b ;  c d])
plot([ω_bos, ω_bos, ω_bos, ω_bos, ω_K1t_NRG, ω_K1t_NRG, ω_K1t_NRG, ω_K1t_NRG], [imag.([K1t_data[:,i,j]./ 2 for i in 1:2, j in 1:2][:]), imag.([K1t_NRG[:,1,j,i,1] for i in 1:2, j in 1:2][:])], layout=l, label=["here" "here" "here" "here" "NRG" "NRG" "NRG" "NRG"], xlims=[-0.5,0.5]) # 




K2t_NRG = matopen("data/SIAM_u=0.50/V_KF_ph/V_KF_U3_1.mat") do f
    read(f, "CFdat")["Ggrid"][1][1,:,:,:,:,:,:]
end
#keys(f)
ω_K2t_NRG = read(f, "CFdat")["ogrid"]
@assert maximum(abs.(ω_K1t_NRG - ω_K2t_NRG[3])) == 0
#K2t_CF = read(f, "CF")
#K2t_CF = nothing




### load selfenergies from Matlab code:
f = matopen("data/SIAM_u=0.50/V_KF_ph/SE_KF_1.mat")
keys(f)
#CF = read(f, "CF")["Hwidth"]
Σ_NRG1 = read(f,"CFdat")["Ggrid"][1]
ω_NRG1 = read(f,"CFdat")["ogrid"][1]
#f = matopen("data/SIAM_u=0.50/V_KF_ph/SE_KF_2.mat")
#keys(f)
#Σ_NRG2 = read(f,"CFdat")["Ggrid"][1]
#ω_NRG2 = read(f,"CFdat")["ogrid"][1]
#f = matopen("data/SIAM_u=0.50/V_KF_ph/SE_KF_3.mat")
#keys(f)
#Σ_NRG3 = read(f,"CFdat")["Ggrid"][1]
#ω_NRG3 = read(f,"CFdat")["ogrid"][1]
#f = matopen("data/SIAM_u=0.50/V_KF_ph/SE_KF_4.mat")
#keys(f)
#Σ_NRG4 = read(f,"CFdat")["Ggrid"][1]
#ω_NRG4 = read(f,"CFdat")["ogrid"][1]



K2tuu = TCI4Keldysh.compute_K2r_symmetric_estimator(
    "KF",
    PSFpath,
    ("Q34", "1", "1dag"),
    Σ_NRG1
    ;
    T,
    flavor_idx = 1,
    ωs_ext = (ω_bos, ω_fer),
    ωconvMat=ωconvMat_K2t,
    sigmak, γ, estep=2000
)

begin
    iω = 111
    α, β, δ = 2, 2, 1
    kindx_NRG = [1,α,β,δ]#[1,2,2,2]
    kindx_here = [α,δ,β]
    l = @layout([a ;  b])
    plot([ω_K1t_NRG ω_fer],[real.([K2t_NRG[:,iω,kindx_NRG...] K2tuu[iω,:,kindx_here...]]), imag.([K2t_NRG[:,iω,kindx_NRG...] K2tuu[iω,:,kindx_here...]]) ], layout = l, label=[["Re(NRG)" "Re(here)"] ["Im(NRG)" "Im(here)"]]) # , t = [:line :histogram :scatter :steppre] , leg = false, ticks = nothing, border = :none
end

#heatmap(real.(K2t_NRG[:,:,1,2,1,1])')
#heatmap(real.(K2tuu[:,:,2,1,1]))
#heatmap(imag.(K2t_NRG[:,:,1,2,1,1])')
#heatmap(imag.(K2tuu[:,:,2,1,1]))





Γcore_uu_NRG = matopen("data/SIAM_u=0.50/V_KF_ph/V_KF_U4.mat") do f
    #keys(f)
    Γcore_uu_NRG = read(f, "CFdat")["Ggrid"][1][51:151,51:151,51:151,:,:,:,:]
end

Γcore_uu = TCI4Keldysh.compute_Γcore_symmetric_estimator(
    "KF",
    PSFpath*"4pt/",
    Σ_NRG1
    ;
    T,
    flavor_idx = 1,
    ωs_ext = (ω_bos[51:151], ω_fer[51:151], ω_fer[51:151]),
    ωconvMat=ωconvMat_t,
    sigmak, γ, estep=2000
)



#h5open("data/KF_SIAM_u=0.50.h5", "w") do file
#    write(file, "vertex_core", Γcore_uu)  # alternatively, say "@write file A"
#end



begin
    iω = 51
    iν = 51
    α, β, δ, ϵ = 1, 2, 2, 1
    kindx_NRG  = [α,β,δ,ϵ] # [1,1,1,2] #
    kindx_here = [β,α,ϵ,δ] # [1,1,2,1] #
    l = @layout([a ;  b])
    plot([ω_K1t_NRG[51:151], ω_fer[51:151]],[real.([Γcore_uu_NRG[iν,:,iω,kindx_NRG...] Γcore_uu[iω,iν,:,kindx_here...]]), imag.([Γcore_uu_NRG[iν,:,iω,kindx_NRG...] Γcore_uu[iω,iν,:,kindx_here...]]) ], layout = l, label=[["Re(NRG)" "Re(here)"] ["Im(NRG)" "Im(here)"]]) # , t = [:line :histogram :scatter :steppre] , leg = false, ticks = nothing, border = :none
end








########################################################################################################
### Yet to be implemented:
### compute selfenergy via (a)symmetric estimators

G0_inv   = ω_fer #.+ im*Δ*sign.(imag.(ω_fer)) .+ U/2
G        = TCI4Keldysh.FullCorrelator_KF(PSFpath, ["F1", "F1dag"]; T, flavor_idx=1, ωs_ext=(ω_fer,), ωconvMat=reshape([ 1; -1], (2,1)), name="SIAM 2pG", sigmak, γ, estep=2000);
G_aux    = TCI4Keldysh.FullCorrelator_KF(PSFpath, ["Q1", "F1dag"]; T, flavor_idx=1, ωs_ext=(ω_fer,), ωconvMat=reshape([ 1; -1], (2,1)), name="SIAM 2pG", sigmak, γ, estep=2000);
G_QQ_aux = TCI4Keldysh.FullCorrelator_KF(PSFpath, ["Q1", "Q1dag"]; T, flavor_idx=1, ωs_ext=(ω_fer,), ωconvMat=reshape([ 1; -1], (2,1)), name="SIAM 2pG", sigmak, γ, estep=2000);

G_data      = TCI4Keldysh.precompute_all_values(G)

plot(-1/π*imag.(G_data[:,2,1]))
plot(real.(G_data[:,2,1]))
@assert maximum(abs.(G_data[:,2,1] - conj.(G_data[:,1,2]))) < 1e-14
@assert maximum(abs.(real.(G_data[:,2,2]))) < 1e-14

G_aux_data  = TCI4Keldysh.precompute_all_values(G_aux)
G_QQ_aux_data=TCI4Keldysh.precompute_all_values(G_QQ_aux)



function calc_Σ_KF_aIE(G_aux::Array{ComplexF64,3}, G::Array{ComplexF64,3}) ::Vector{ComplexF64}
    return TCI4Keldysh.calc_Σ_MF_aIE(G_aux[:,2,1], G[:,2,1])     # retarded
end

Σ_aIE = calc_Σ_KF_aIE(G_aux_data, G_data)
plot(real.(Σ_aIE))
plot(imag.(Σ_aIE))